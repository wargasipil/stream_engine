package main

import (
	"container/list"
	"encoding/binary"
	"fmt"
	"hash/fnv"
	"os"
	"sync"

	"github.com/edsrzf/mmap-go"
)

const (
	SlotSize = 16 // 8 bytes key hash + 8 bytes counter
	MaxSlots = 1_000_000
)

// ------------------ Counter ------------------

type KVCounter struct {
	data  mmap.MMap
	slots uint64

	nextSlot uint64

	mu    sync.Mutex
	lru   *list.List
	index map[string]*list.Element
}

type entry struct {
	key  string
	slot uint64
}

// ------------------ Init ------------------

func NewKVCounter(path string, slots uint64) (*KVCounter, error) {
	size := int(slots * SlotSize)

	f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0644)
	if err != nil {
		return nil, err
	}

	if err := f.Truncate(int64(size)); err != nil {
		return nil, err
	}

	m, err := mmap.Map(f, mmap.RDWR, 0)
	if err != nil {
		return nil, err
	}

	return &KVCounter{
		data:  m,
		slots: slots,
		lru:   list.New(),
		index: make(map[string]*list.Element),
	}, nil
}

// ------------------ Hash ------------------

func hashKey(key string) uint64 {
	h := fnv.New64a()
	h.Write([]byte(key))
	return h.Sum64()
}

// ------------------ Counter Ops ------------------

func (c *KVCounter) Increment(key string) uint64 {
	c.mu.Lock()
	defer c.mu.Unlock()

	if elem, ok := c.index[key]; ok {
		c.lru.MoveToFront(elem)
		e := elem.Value.(*entry)
		offset := e.slot * SlotSize
		value := binary.LittleEndian.Uint64(c.data[offset+8:])
		value++
		binary.LittleEndian.PutUint64(c.data[offset+8:], value)
		return value
	}

	var slot uint64
	if c.nextSlot < c.slots {
		slot = c.nextSlot
		c.nextSlot++
	} else {
		// Evict least recently used
		back := c.lru.Back()
		if back == nil {
			return 0
		}
		e := back.Value.(*entry)
		delete(c.index, e.key)
		c.lru.Remove(back)
		slot = e.slot
	}

	offset := slot * SlotSize

	// Store hash in mmap for potential future use/debugging.
	h := hashKey(key)
	binary.LittleEndian.PutUint64(c.data[offset:], h)
	binary.LittleEndian.PutUint64(c.data[offset+8:], 1)

	elem := c.lru.PushFront(&entry{key: key, slot: slot})
	c.index[key] = elem

	return 1
}

func (c *KVCounter) Get(key string) uint64 {
	c.mu.Lock()
	defer c.mu.Unlock()

	if elem, ok := c.index[key]; ok {
		c.lru.MoveToFront(elem)
		e := elem.Value.(*entry)
		offset := e.slot * SlotSize
		return binary.LittleEndian.Uint64(c.data[offset+8:])
	}
	return 0
}

func (c *KVCounter) Close() error {
	if err := c.data.Flush(); err != nil {
		return err
	}
	return c.data.Unmap()
}

// ------------------ Demo ------------------

func main() {
	counter, err := NewKVCounter("counter.db", MaxSlots)
	if err != nil {
		panic(err)
	}
	defer counter.Close()

	counter.Increment("user:123")
	counter.Increment("user:123")
	counter.Increment("user:456")

	fmt.Println("user:123 =", counter.Get("user:123"))
	fmt.Println("user:456 =", counter.Get("user:456"))
	fmt.Println("user:999 =", counter.Get("user:999"))
}
